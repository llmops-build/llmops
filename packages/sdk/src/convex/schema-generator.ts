/**
 * Convex Schema Generator
 *
 * This module generates a Convex schema.ts file from the LLMOps SCHEMA_METADATA.
 * The generated schema can be copied into your Convex project's convex/schema.ts file.
 *
 * @example
 * ```ts
 * import { generateConvexSchema } from '@llmops/sdk/convex';
 *
 * const schemaContent = generateConvexSchema();
 * console.log(schemaContent);
 * // Copy the output to your convex/schema.ts file
 * ```
 */

import { SCHEMA_METADATA } from '@llmops/core';

/**
 * Map SQL types to Convex types
 */
function mapSqlTypeToConvex(
  sqlType: string,
  options: { nullable?: boolean; primaryKey?: boolean }
): string {
  const baseType = (() => {
    switch (sqlType.toLowerCase()) {
      case 'uuid':
        return 'v.string()';
      case 'text':
        return 'v.string()';
      case 'integer':
        return 'v.number()';
      case 'boolean':
        return 'v.boolean()';
      case 'timestamp':
        return 'v.string()'; // ISO date string
      case 'jsonb':
      case 'json':
        return 'v.any()'; // Convex supports any for JSON
      default:
        return 'v.string()';
    }
  })();

  // Handle nullable
  if (options.nullable) {
    return `v.optional(${baseType})`;
  }

  return baseType;
}

/**
 * Convert snake_case to camelCase
 */
function snakeToCamel(str: string): string {
  return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Generate Convex table definition from SCHEMA_METADATA
 */
function generateTableDefinition(
  tableName: string,
  tableMetadata: (typeof SCHEMA_METADATA.tables)[keyof typeof SCHEMA_METADATA.tables]
): string {
  const fields: string[] = [];

  for (const [fieldName, fieldDef] of Object.entries(tableMetadata.fields)) {
    // Skip id field - Convex generates _id automatically
    if (fieldName === 'id') {
      // But we might want to keep our own uuid field for compatibility
      fields.push(`    id: v.string(), // UUID for cross-database compatibility`);
      continue;
    }

    const convexFieldName = snakeToCamel(fieldName);
    const convexType = mapSqlTypeToConvex(fieldDef.type, {
      nullable: (fieldDef as any).nullable === true,
      primaryKey: (fieldDef as any).primaryKey === true,
    });

    // Add field with optional reference comment
    if ((fieldDef as any).references) {
      const ref = (fieldDef as any).references as { table: string; column: string };
      fields.push(
        `    ${convexFieldName}: ${convexType}, // FK: ${ref.table}.${ref.column}`
      );
    } else {
      fields.push(`    ${convexFieldName}: ${convexType},`);
    }
  }

  // Convert table name to camelCase for Convex
  const convexTableName = snakeToCamel(tableName);

  return `  ${convexTableName}: defineTable({
${fields.join('\n')}
  })`;
}

/**
 * Generate index definitions for a table
 */
function generateIndexDefinitions(
  tableName: string,
  tableMetadata: (typeof SCHEMA_METADATA.tables)[keyof typeof SCHEMA_METADATA.tables]
): string[] {
  const indexes: string[] = [];

  for (const [fieldName, fieldDef] of Object.entries(tableMetadata.fields)) {
    const convexFieldName = snakeToCamel(fieldName);

    // Add index for unique fields
    if ((fieldDef as any).unique) {
      indexes.push(`    .index('by_${fieldName}', ['${convexFieldName}'])`);
    }

    // Add index for foreign keys
    if ((fieldDef as any).references) {
      indexes.push(`    .index('by_${fieldName}', ['${convexFieldName}'])`);
    }
  }

  // Add default indexes
  indexes.push(`    .index('by_createdAt', ['createdAt'])`);

  return indexes;
}

/**
 * Generate the complete Convex schema from SCHEMA_METADATA
 *
 * @returns A string containing the complete convex/schema.ts file content
 */
export function generateConvexSchema(): string {
  const tableDefinitions: string[] = [];

  // Sort tables by order
  const sortedTables = Object.entries(SCHEMA_METADATA.tables).sort(
    ([, a], [, b]) => a.order - b.order
  );

  for (const [tableName, tableMetadata] of sortedTables) {
    const tableDef = generateTableDefinition(tableName, tableMetadata);
    const indexes = generateIndexDefinitions(tableName, tableMetadata);

    if (indexes.length > 0) {
      tableDefinitions.push(`${tableDef}\n${indexes.join('\n')}`);
    } else {
      tableDefinitions.push(tableDef);
    }
  }

  return `/**
 * LLMOps Convex Schema
 *
 * This schema is auto-generated from @llmops/core SCHEMA_METADATA.
 * Do not edit this file directly - regenerate using:
 *
 *   import { generateConvexSchema } from '@llmops/sdk/convex';
 *   console.log(generateConvexSchema());
 *
 * @generated
 */
import { defineSchema, defineTable } from 'convex/server';
import { v } from 'convex/values';

export default defineSchema({
${tableDefinitions.join(',\n\n')},
});
`;
}

/**
 * Generate Convex CRUD functions template
 *
 * This generates a template for the generic CRUD functions needed by the Convex adapter.
 * These functions should be added to your Convex project.
 */
export function generateConvexFunctionsTemplate(): string {
  return `/**
 * LLMOps Convex Functions
 *
 * These are the generic CRUD functions required by the LLMOps Convex adapter.
 * Add these to your Convex project (e.g., convex/llmops.ts).
 *
 * @generated
 */
import { v } from 'convex/values';
import { mutation, query } from './_generated/server';

// Generic filter type
const filterArg = v.array(
  v.object({
    field: v.string(),
    operator: v.string(),
    value: v.any(),
  })
);

/**
 * Create a single document
 */
export const create = mutation({
  args: {
    table: v.string(),
    data: v.any(),
  },
  handler: async (ctx, { table, data }) => {
    // Generate a UUID for cross-database compatibility
    const id = crypto.randomUUID();
    const now = new Date().toISOString();

    const doc = {
      ...data,
      id,
      createdAt: data.createdAt ?? now,
      updatedAt: data.updatedAt ?? now,
    };

    // @ts-expect-error - Dynamic table access
    const _id = await ctx.db.insert(table, doc);

    return { ...doc, _id };
  },
});

/**
 * Create multiple documents
 */
export const createMany = mutation({
  args: {
    table: v.string(),
    data: v.array(v.any()),
  },
  handler: async (ctx, { table, data }) => {
    const now = new Date().toISOString();

    for (const item of data) {
      const id = crypto.randomUUID();
      const doc = {
        ...item,
        id,
        createdAt: item.createdAt ?? now,
        updatedAt: item.updatedAt ?? now,
      };

      // @ts-expect-error - Dynamic table access
      await ctx.db.insert(table, doc);
    }

    return { count: data.length };
  },
});

/**
 * Find a single document
 */
export const findOne = query({
  args: {
    table: v.string(),
    filter: filterArg,
    select: v.optional(v.array(v.string())),
  },
  handler: async (ctx, { table, filter }) => {
    // @ts-expect-error - Dynamic table access
    let query = ctx.db.query(table);

    // Apply filters
    for (const condition of filter) {
      query = applyFilter(query, condition);
    }

    const result = await query.first();
    return result ?? null;
  },
});

/**
 * Find multiple documents
 */
export const findMany = query({
  args: {
    table: v.string(),
    filter: filterArg,
    limit: v.optional(v.number()),
    offset: v.optional(v.number()),
    orderBy: v.optional(
      v.union(
        v.object({ field: v.string(), direction: v.string() }),
        v.array(v.object({ field: v.string(), direction: v.string() }))
      )
    ),
    select: v.optional(v.array(v.string())),
  },
  handler: async (ctx, { table, filter, limit, orderBy }) => {
    // @ts-expect-error - Dynamic table access
    let query = ctx.db.query(table);

    // Apply filters
    for (const condition of filter) {
      query = applyFilter(query, condition);
    }

    // Apply ordering
    if (orderBy) {
      const orders = Array.isArray(orderBy) ? orderBy : [orderBy];
      for (const order of orders) {
        query = query.order(order.direction === 'desc' ? 'desc' : 'asc');
      }
    }

    // Get results
    let results = await query.collect();

    // Apply limit (Convex doesn't have native offset)
    if (limit !== undefined) {
      results = results.slice(0, limit);
    }

    return results;
  },
});

/**
 * Update a single document
 */
export const update = mutation({
  args: {
    table: v.string(),
    filter: filterArg,
    data: v.any(),
  },
  handler: async (ctx, { table, filter, data }) => {
    // @ts-expect-error - Dynamic table access
    let query = ctx.db.query(table);

    for (const condition of filter) {
      query = applyFilter(query, condition);
    }

    const doc = await query.first();
    if (!doc) {
      return null;
    }

    const now = new Date().toISOString();
    const updateData = {
      ...data,
      updatedAt: now,
    };

    await ctx.db.patch(doc._id, updateData);

    return { ...doc, ...updateData };
  },
});

/**
 * Delete a single document
 */
export const deleteOne = mutation({
  args: {
    table: v.string(),
    filter: filterArg,
  },
  handler: async (ctx, { table, filter }) => {
    // @ts-expect-error - Dynamic table access
    let query = ctx.db.query(table);

    for (const condition of filter) {
      query = applyFilter(query, condition);
    }

    const doc = await query.first();
    if (doc) {
      await ctx.db.delete(doc._id);
    }
  },
});

/**
 * Delete multiple documents
 */
export const deleteMany = mutation({
  args: {
    table: v.string(),
    filter: filterArg,
  },
  handler: async (ctx, { table, filter }) => {
    // @ts-expect-error - Dynamic table access
    let query = ctx.db.query(table);

    for (const condition of filter) {
      query = applyFilter(query, condition);
    }

    const docs = await query.collect();

    for (const doc of docs) {
      await ctx.db.delete(doc._id);
    }

    return { count: docs.length };
  },
});

/**
 * Count documents
 */
export const count = query({
  args: {
    table: v.string(),
    filter: filterArg,
  },
  handler: async (ctx, { table, filter }) => {
    // @ts-expect-error - Dynamic table access
    let query = ctx.db.query(table);

    for (const condition of filter) {
      query = applyFilter(query, condition);
    }

    const docs = await query.collect();
    return docs.length;
  },
});

/**
 * Helper to apply filter conditions
 */
function applyFilter(query: any, condition: { field: string; operator: string; value: any }) {
  const { field, operator, value } = condition;

  switch (operator) {
    case 'eq':
      return query.filter((q: any) => q.eq(q.field(field), value));
    case 'neq':
      return query.filter((q: any) => q.neq(q.field(field), value));
    case 'gt':
      return query.filter((q: any) => q.gt(q.field(field), value));
    case 'gte':
      return query.filter((q: any) => q.gte(q.field(field), value));
    case 'lt':
      return query.filter((q: any) => q.lt(q.field(field), value));
    case 'lte':
      return query.filter((q: any) => q.lte(q.field(field), value));
    case 'isNull':
      return query.filter((q: any) => q.eq(q.field(field), null));
    case 'isNotNull':
      return query.filter((q: any) => q.neq(q.field(field), null));
    default:
      return query.filter((q: any) => q.eq(q.field(field), value));
  }
}
`;
}

/**
 * Print the Convex schema to console
 *
 * Convenience function for CLI usage
 */
export function printConvexSchema(): void {
  console.log(generateConvexSchema());
}

/**
 * Print the Convex functions template to console
 *
 * Convenience function for CLI usage
 */
export function printConvexFunctionsTemplate(): void {
  console.log(generateConvexFunctionsTemplate());
}
